import { computed, reactive, ref, toRaw, toValue } from "vue";
import { debounce, isEqual } from "lodash-es";
import { objectToFormData } from "object-form-encoder";
import { usePrecognitionConfig } from "../composables/usePrecognitionConfig.js";
import {
  PRECOGNITION_HEADER,
  PRECOGNITION_ONLY_HEADER,
  PRECOGNITION_SUCCESS_HEADER,
  STATUS_NO_CONTENT,
  STATUS_VALIDATION_ERROR
} from "../utils/constants.js";
import { clearFiles, hasFiles } from "../utils/files.js";
import { useSanctumClient } from "#imports";
export const usePrecognitionForm = (method, url, payload) => {
  const _originalPayload = structuredClone(payload);
  const _originalPayloadKeys = Object.keys(_originalPayload);
  const _validated = ref([]);
  const _touched = ref([]);
  const _config = usePrecognitionConfig();
  const _client = useSanctumClient();
  async function process(params = {
    precognitive: false,
    fields: [],
    options: {}
  }) {
    let payload2 = form.data();
    const headers = new Headers();
    const includeFiles = params.options?.validateFiles ?? _config.validateFiles;
    if (hasFiles(payload2)) {
      if (params.precognitive && !includeFiles) {
        console.warn("Files were detected in the payload but will not be sent. To include files, set `validateFiles` to `true` in the validation options or module config.");
        payload2 = clearFiles(payload2);
      } else {
        payload2 = objectToFormData(payload2);
      }
    }
    if (params.precognitive) {
      headers.set(PRECOGNITION_HEADER, "true");
      if (params.fields.length > 0 && params.fields.length !== _originalPayloadKeys.length) {
        headers.set(PRECOGNITION_ONLY_HEADER, params.fields.join());
      }
    }
    const request_url = toValue(url), request_method = toValue(method);
    const response = await _client.raw(request_url, {
      method: request_method,
      ...["get", "delete"].includes(request_method) ? { query: payload2 } : { body: payload2 },
      headers,
      ignoreResponseError: true
    });
    if (params.precognitive) {
      if (response.headers.get(PRECOGNITION_HEADER) !== "true") {
        console.warn("Did not receive a Precognition response. Ensure you have the Precognition middleware in place for the route.");
      }
      if (response.status === STATUS_NO_CONTENT && response.headers.get(PRECOGNITION_SUCCESS_HEADER) === "true") {
        if (params.fields.length > 0) {
          const validatedNew = new Set(_validated.value);
          params.fields.forEach((field) => {
            validatedNew.add(field);
            form.forgetError(field);
          });
          _validated.value = [...validatedNew];
        } else {
          _validated.value = _originalPayloadKeys;
          form.setErrors({});
        }
      }
    }
    if (response.ok) {
      return Promise.resolve(response);
    }
    if (response.status === STATUS_VALIDATION_ERROR) {
      const validationResponse = response._data;
      if (params.fields.length == 0) {
        form.setErrors(validationResponse.errors);
      } else {
        const currentErrors = form.errors;
        const newErrors = validationResponse.errors;
        for (const field in newErrors) {
          currentErrors[field] = newErrors[field];
        }
      }
    }
    return Promise.reject(response);
  }
  const form = reactive({
    fields: payload,
    errors: {},
    processing: false,
    validating: false,
    hasErrors: computed(() => Object.keys(form.errors).length > 0),
    wasSuccessful: false,
    recentlySuccessful: false,
    touched: (name) => _touched.value.includes(name),
    valid: (name) => _validated.value.includes(name) && !form.invalid(name),
    invalid: (name) => typeof form.errors[name] !== "undefined",
    data() {
      return toRaw(form.fields);
    },
    setData(data) {
      Object.keys(data).forEach((key) => {
        form.fields[key] = data[key];
      });
      return form;
    },
    touch(name) {
      const inputs = Array.isArray(name) ? name : [name];
      const fields = [..._touched.value, ...inputs];
      const newTouched = [...new Set(fields)];
      const hasNewFields = newTouched.length !== _touched.value.length || newTouched.every((x) => _touched.value.includes(x));
      if (hasNewFields) {
        _touched.value = newTouched;
      }
      return form;
    },
    reset(...keys) {
      const resetField = (fieldName) => {
        form.fields[fieldName] = _originalPayload[fieldName];
        form.forgetError(fieldName);
      };
      if (keys.length === 0) {
        _originalPayloadKeys.forEach((name) => resetField(name));
        _touched.value = [];
        _validated.value = [];
      }
      const newTouched = [..._touched.value];
      const newValidated = [..._validated.value];
      keys.forEach((name) => {
        resetField(name);
        if (newTouched.includes(name)) {
          newTouched.splice(newTouched.indexOf(name), 1);
        }
        if (newValidated.includes(name)) {
          newValidated.splice(newValidated.indexOf(name), 1);
        }
      });
      _touched.value = newTouched;
      _validated.value = newValidated;
      return form;
    },
    setErrors(entries) {
      if (!isEqual(form.errors, entries)) {
        form.errors = entries;
      }
      return form;
    },
    forgetError(name) {
      const {
        [name]: _,
        ...newErrors
      } = form.errors;
      return form.setErrors(newErrors);
    },
    validate(name, options) {
      if (typeof name === "undefined") {
        name = [];
      }
      const fields = Array.isArray(name) ? name : [name];
      form.validating = true;
      process({ precognitive: true, fields, options }).then((response) => {
        if (!options?.onSuccess) {
          return;
        }
        options.onSuccess(response);
      }).catch((response) => {
        if (response.status === STATUS_VALIDATION_ERROR) {
          if (!options?.onValidationError) {
            return;
          }
          options.onValidationError(response);
          return;
        }
        if (!options?.onError) {
          return;
        }
        options.onError(response);
      }).finally(() => form.validating = false);
      return form;
    },
    async validateWithErrors() {
      form.validating = true;
      try {
        await process({ precognitive: true, fields: [] }).finally(() => form.validating = false);
      } catch {
        return form.errors;
      }
      return {};
    },
    async submit() {
      form.processing = true;
      return await process().then((response) => {
        form.wasSuccessful = true;
        form.recentlySuccessful = true;
        debounce(
          () => {
            form.recentlySuccessful = false;
          },
          2e3
        )();
        return response;
      }).catch((response) => {
        form.wasSuccessful = false;
        throw response;
      }).finally(() => form.processing = false);
    }
  });
  if (_config.validationTimeout > 0) {
    form.validate = debounce(form.validate, _config.validationTimeout);
  }
  return form;
};
